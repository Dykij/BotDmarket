# Руководство по логированию и обработке ошибок

## Обзор

Данное руководство описывает принципы и практики логирования и обработки ошибок в проекте DMarket Tools.
Реализованный подход обеспечивает унифицированное логирование с контекстной информацией и структурированный подход к обработке исключений.

## Модули

### `src/utils/logging_utils.py`

Модуль предоставляет централизованный механизм логирования с добавлением контекстной информации.

#### Основные компоненты

1. `get_logger(name, context)` - основная функция для получения настроенного логгера
2. `ContextLogAdapter` - адаптер для добавления контекстной информации в логи
3. `log_exceptions` - декоратор для логирования исключений
4. Предварительно настроенные логгеры для разных компонентов системы

#### Пример использования

```python
from src.utils.logging_utils import get_logger

# Создание логгера с контекстом
logger = get_logger("my_module", {"user_id": 12345, "component": "authentication"})

# Логирование с дополнительным контекстом
logger.info("Пользователь авторизован", extra={"context": {"auth_method": "oauth"}})

# Использование декоратора для автоматического логирования исключений
from src.utils.logging_utils import log_exceptions

@log_exceptions
def divide(a, b):
    return a / b
```

### `src/utils/exception_handling.py`

Модуль определяет иерархию исключений и предоставляет механизмы для их обработки.

#### Основные компоненты

1. `BaseAppException` - базовый класс для всех исключений приложения
2. Специализированные исключения (`APIError`, `ValidationError`, `BusinessLogicError`)
3. `handle_exceptions` - декоратор для обработки исключений с логированием
4. `ErrorCode` - перечисление со стандартными кодами ошибок

#### Пример использования

```python
from src.utils.exception_handling import APIError, handle_exceptions, ErrorCode

# Выброс исключения с контекстной информацией
def api_request():
    raise APIError(
        message="Не удалось выполнить запрос",
        status_code=429,
        details={"endpoint": "/api/v1/items", "retry_after": 30}
    )

# Использование декоратора для обработки исключений
@handle_exceptions(default_error_message="Ошибка при работе с DMarket API")
def fetch_items():
    return api_request()
```

## Рекомендации по логированию

### Уровни логирования

- `DEBUG` - детальная отладочная информация
- `INFO` - общая информация о ходе выполнения
- `WARNING` - предупреждения о возможных проблемах
- `ERROR` - ошибки, которые позволяют продолжить работу
- `CRITICAL` - критические ошибки, требующие внимания

### Контекстная информация

При логировании важно предоставлять дополнительный контекст:

- ID пользователя или сессии
- Компонент системы
- Временные метки
- Параметры операции
- Идентификаторы запросов

### Примеры хороших сообщений лога

```
✅ "Получен ответ от API DMarket со статусом 200"
✅ "Попытка авторизации пользователя {user_id} не удалась"
✅ "Найдено {count} товаров по запросу {query}"
```

### Примеры плохих сообщений лога

```
❌ "Ошибка" (слишком общее)
❌ "Функция выполнилась" (неинформативно)
❌ "x = 5, y = 10" (без контекста)
```

## Рекомендации по обработке ошибок

### Иерархия исключений

Используйте правильную иерархию исключений:

- `BaseAppException` - корень иерархии
  - `APIError` - для ошибок внешних API
  - `ValidationError` - для ошибок валидации
  - `BusinessLogicError` - для ошибок бизнес-логики

### Обработка исключений

1. **Используйте декораторы**: Применяйте `handle_exceptions` для унификации обработки
2. **Предоставляйте контекст**: Всегда включайте детальную информацию об ошибке
3. **Обрабатывайте специфичные исключения**: Избегайте `except Exception`
4. **Не скрывайте ошибки**: Всегда логируйте исключения

### Пример обработки ошибок в боте

```python
@handle_exceptions(logger=bot_logger)
async def process_message(update, context):
    user_id = update.effective_user.id

    try:
        result = await api_client.fetch_data()
        await update.message.reply_text(f"Данные получены: {result}")
    except APIError as e:
        # Обработка и информирование пользователя
        await update.message.reply_text(f"Не удалось получить данные: {e.message}")
        # Не нужно перевыбрасывать, так как handle_exceptions залогирует ошибку
```

## Настройка уровня логирования

Уровень логирования может быть настроен через переменную окружения `LOG_LEVEL`:

```
LOG_LEVEL=DEBUG
```

Доступные уровни: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`
