"""Тесты для модуля sales_analysis_callbacks."""

import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from typing import Dict, Any, List, Optional

from src.telegram_bot.sales_analysis_callbacks import (
    handle_sales_history_callback,
    handle_liquidity_callback,
    handle_all_arbitrage_sales_callback
)


@pytest.fixture
def mock_update_and_context():
    """Создает моки для Update и CallbackContext."""
    # Создаем мок для Update
    update = MagicMock()
    query = MagicMock()
    update.callback_query = query
    query.answer = AsyncMock()
    query.edit_message_text = AsyncMock()
    query.data = "sales_history:AWP | Asiimov (Field-Tested)"
    query.from_user.id = 12345

    # Создаем мок для CallbackContext
    context = MagicMock()
    context.user_data = {}

    return update, context


@pytest.fixture
def mock_sales_data() -> List[Dict[str, Any]]:
    """Создает фиктивные данные продаж для тестов."""
    return [
        {"date": "2023-01-01T12:00:00Z", "price": {"USD": 35.5}},
        {"date": "2023-01-02T13:00:00Z", "price": {"USD": 36.0}},
        {"date": "2023-01-03T14:00:00Z", "price": {"USD": 35.7}},
        {"date": "2023-01-04T15:00:00Z", "price": {"USD": 36.2}},
        {"date": "2023-01-05T16:00:00Z", "price": {"USD": 36.5}}
    ]


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.get_sales_history")
@patch("src.telegram_bot.sales_analysis_callbacks.analyze_sales_history")
async def test_handle_sales_history_callback_success(
    mock_analyze_sales, mock_get_sales, mock_update_and_context, mock_sales_data
):
    """Тест успешной обработки запроса истории продаж."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка моков
    mock_get_sales.return_value = mock_sales_data
    mock_analyze_sales.return_value = {
        "avg_price": 36.0,
        "min_price": 35.5,
        "max_price": 36.5,
        "volatility": 0.8,
        "trend": 0.2,
        "volume": 5
    }

    # Вызов функции
    await handle_sales_history_callback(update, context)

    # Проверки
    update.callback_query.answer.assert_called_once()
    mock_get_sales.assert_called_once()
    mock_analyze_sales.assert_called_once_with(mock_sales_data)
    assert update.callback_query.edit_message_text.call_count == 2

        # Проверка содержимого сообщения (последний вызов)
        call_args = update.callback_query.edit_message_text.call_args[1]
        assert "AWP | Asiimov" in call_args["text"]
        assert "Анализ продаж" in call_args["text"]
        assert "Средняя цена: $36.00" in call_args["text"]


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.get_sales_history")
async def test_handle_sales_history_callback_no_data(
    mock_get_sales, mock_update_and_context
):
    """Тест обработки запроса истории продаж при отсутствии данных."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка моков
    mock_get_sales.return_value = []

    # Вызов функции
    await handle_sales_history_callback(update, context)        # Проверки
        update.callback_query.answer.assert_called_once()
        mock_get_sales.assert_called_once()
        assert update.callback_query.edit_message_text.call_count >= 1

        # Проверка содержимого сообщения (последний вызов)
        call_args = update.callback_query.edit_message_text.call_args[1]
        assert "не найдено" in call_args["text"].lower() or "нет данных" in call_args["text"].lower() or "ошибка" in call_args["text"].lower()


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.get_sales_history")
async def test_handle_sales_history_callback_api_error(
    mock_get_sales, mock_update_and_context
):
    """Тест обработки API ошибки при запросе истории продаж."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка моков для имитации API ошибки
    mock_get_sales.side_effect = Exception("API error")

    # Вызов функции
    await handle_sales_history_callback(update, context)        # Проверки
        update.callback_query.answer.assert_called_once()
        mock_get_sales.assert_called_once()
        assert update.callback_query.edit_message_text.call_count >= 1

        # Проверка содержимого сообщения (последний вызов)
        call_args = update.callback_query.edit_message_text.call_args[1]
        assert "ошибка" in call_args["text"].lower()
        assert "api error" in call_args["text"].lower()


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.analyze_item_liquidity")
async def test_handle_liquidity_callback_success(
    mock_analyze_liquidity, mock_update_and_context
):
    """Тест успешной обработки запроса ликвидности предмета."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка для теста ликвидности
    update.callback_query.data = "liquidity:AWP | Asiimov (Field-Tested)"

    # Настройка мока
    mock_analyze_liquidity.return_value = {
        "liquidity_score": 8.5,
        "sales_per_day": 12.3,
        "avg_price": 36.0,
        "price_trend": 0.2,
        "price_stability": 0.9
    }

    # Вызов функции
    await handle_liquidity_callback(update, context)        # Проверки
        update.callback_query.answer.assert_called_once()
        mock_analyze_liquidity.assert_called_once()
        assert update.callback_query.edit_message_text.call_count >= 1

        # Проверяем, что в последнем сообщении есть информация о ликвидности
        # или об ошибке (в зависимости от реализации)
        call_args = update.callback_query.edit_message_text.call_args[1]
        if "ошибка" not in call_args["text"].lower():
            assert "AWP | Asiimov" in call_args["text"]
            assert "Ликвидность" in call_args["text"] or "ликвидности" in call_args["text"]


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.analyze_item_liquidity")
async def test_handle_liquidity_callback_no_data(
    mock_analyze_liquidity, mock_update_and_context
):
    """Тест обработки запроса ликвидности при отсутствии данных."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка для теста ликвидности
    update.callback_query.data = "liquidity:AWP | Asiimov (Field-Tested)"

    # Настройка мока
    mock_analyze_liquidity.return_value = None

    # Вызов функции
    await handle_liquidity_callback(update, context)        # Проверки
        update.callback_query.answer.assert_called_once()
        mock_analyze_liquidity.assert_called_once()
        assert update.callback_query.edit_message_text.call_count >= 1

        # Проверка содержимого последнего сообщения
        call_args = update.callback_query.edit_message_text.call_args[1]
        assert any(msg in call_args["text"].lower() for msg in ["не найдено", "нет данных", "ошибка"])


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.enhanced_arbitrage_search")
async def test_handle_all_arbitrage_sales_callback(
    mock_enhanced_search, mock_update_and_context
):
    """Тест обработки запроса улучшенного арбитража."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка для теста улучшенного арбитража
    update.callback_query.data = "all_arbitrage_sales:csgo"

    # Тестовые данные арбитража
    arbitrage_items = [
        {
            "title": "AK-47 | Redline (Field-Tested)",
            "price": {"amount": 1000},  # $10.00
            "profit": 200,              # $2.00 прибыль
            "liquidity_score": 9.5,
            "sales_per_day": 25.0
        },
        {
            "title": "AWP | Asiimov (Field-Tested)",
            "price": {"amount": 3000},  # $30.00
            "profit": 400,              # $4.00 прибыль
            "liquidity_score": 8.0,
            "sales_per_day": 15.0
        }
    ]

    # Настройка мока
    mock_enhanced_search.return_value = arbitrage_items

    # Вызов функции
    await handle_all_arbitrage_sales_callback(update, context)        # Проверки
        update.callback_query.answer.assert_called_once()
        mock_enhanced_search.assert_called_once()
        assert update.callback_query.edit_message_text.call_count >= 1

        # Проверка содержимого сообщения
        call_args = update.callback_query.edit_message_text.call_args[1]
        if "ошибка" not in call_args["text"].lower():
            assert "арбитраж" in call_args["text"].lower() or "торговля" in call_args["text"].lower()
            assert "redline" in call_args["text"].lower() or "ak-47" in call_args["text"].lower()
            assert "asiimov" in call_args["text"].lower() or "awp" in call_args["text"].lower()


@pytest.mark.asyncio
@patch("src.telegram_bot.sales_analysis_callbacks.enhanced_arbitrage_search")
async def test_handle_all_arbitrage_sales_callback_empty_result(
    mock_enhanced_search, mock_update_and_context
):
    """Тест обработки запроса арбитража с пустым результатом."""
    # Распаковка моков
    update, context = mock_update_and_context

    # Настройка для теста улучшенного арбитража
    update.callback_query.data = "all_arbitrage_sales:csgo"

    # Настройка мока для пустого результата
    mock_enhanced_search.return_value = []

    # Вызов функции
    await handle_all_arbitrage_sales_callback(update, context)

    # Проверки
    update.callback_query.answer.assert_called_once()
    mock_enhanced_search.assert_called_once()
    update.callback_query.edit_message_text.assert_called_once()

    # Проверка содержимого сообщения
    call_args = update.callback_query.edit_message_text.call_args[1]
    assert ("не найдено" in call_args["text"].lower() or
            "нет данных" in call_args["text"].lower() or
            "не обнаружено" in call_args["text"].lower())
