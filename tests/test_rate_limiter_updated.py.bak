"""
Расширенные модульные тесты для Rate Limiter.
"""

import pytest
import asyncio
import time
from unittest.mock import patch, MagicMock, AsyncMock

from src.utils.rate_limiter import RateLimiter, DEFAULT_API_RATE_LIMITS


@pytest.fixture
def limiter():
    """Создает экземпляр RateLimiter для тестов."""
    return RateLimiter(is_authorized=False)


def test_init():
    """Проверка корректной инициализации RateLimiter."""
    limiter = RateLimiter()

    # Проверяем, что флаг авторизации установлен по умолчанию
    assert limiter.is_authorized is True

    # Проверяем, что словари инициализированы
    assert hasattr(limiter, "custom_limits")
    assert hasattr(limiter, "last_request_times")
    assert hasattr(limiter, "reset_times")
    assert hasattr(limiter, "request_counters")

    # Создаем экземпляр с не авторизованным доступом
    limiter_unauth = RateLimiter(is_authorized=False)
    assert limiter_unauth.is_authorized is False


def test_get_endpoint_type():
    """Проверка корректного определения типа эндпоинта."""
    limiter = RateLimiter()

    # Тестируем маркет-эндпоинты
    assert limiter.get_endpoint_type("/marketplace-api/v1/items") == "market"
    assert limiter.get_endpoint_type("/items/popular") == "market"

    # Тестируем торговые эндпоинты
    assert limiter.get_endpoint_type("/exchange/v1/buy") == "trade"
    assert limiter.get_endpoint_type("/offers/my") == "trade"

    # Тестируем пользовательские эндпоинты
    assert limiter.get_endpoint_type("/account/profile") == "user"
    assert limiter.get_endpoint_type("/user/balance") == "user"

    # Тестируем прочие эндпоинты
    assert limiter.get_endpoint_type("/status") == "other"
    assert limiter.get_endpoint_type("/unknown/endpoint") == "other"

@pytest.mark.asyncio
async def test_wait_if_needed_simple():
    """Базовый тест ожидания лимита запросов."""
        limiter = RateLimiter()

        # Нет предыдущих запросов, ожидания не должно быть
        start_time = time.time()
        await limiter.wait_if_needed("market")
        duration = time.time() - start_time

        # Не должно быть значительного ожидания
        assert duration < 0.1

        # Проверяем, что время запроса было сохранено
        assert "market" in limiter.last_request_times    @pytest.mark.asyncio
    async def test_wait_if_needed_with_delay():
        """Проверка ожидания после предыдущего запроса."""
        limiter = RateLimiter()

        # Устанавливаем низкий лимит запросов (1 запрос в 0.5 секунд)
        limiter.custom_limits["market"] = 2  # 2 RPS = 1 запрос в 0.5 секунд

        # Симулируем предыдущий запрос только что
        limiter.last_request_times["market"] = time.time()

        # Запускаем ожидание для следующего запроса
        start_time = time.time()
        await limiter.wait_if_needed("market")
        duration = time.time() - start_time

        # Должно быть ожидание около 0.5 секунд
        # Добавляем допуски из-за неточностей в замерах времени
        assert 0.3 < duration < 0.7    @pytest.mark.asyncio
    async def test_wait_if_needed_with_path():
        """Проверка ожидания с использованием пути вместо типа эндпоинта."""
        with patch.object(RateLimiter, 'get_endpoint_type', return_value="market") as mock_get_type:
            limiter = RateLimiter()

            # Симулируем предыдущий запрос только что
            limiter.last_request_times["market"] = time.time()
            limiter.custom_limits["market"] = 20  # высокий лимит для быстрых тестов

            # Определяем тип эндпоинта для пути
            endpoint_type = limiter.get_endpoint_type("/marketplace-api/v1/items")

            # Ожидание для следующего запроса с типом эндпоинта
            await limiter.wait_if_needed(endpoint_type)

            # Проверяем, что правильно определился тип эндпоинта
            mock_get_type.assert_called_once_with("/marketplace-api/v1/items")


def test_update_from_headers():
    """Базовое тестирование обновления лимитов из заголовков."""
    limiter = RateLimiter()

    # Тестовые заголовки
    headers = {
        "X-RateLimit-Remaining": "10",
        "X-RateLimit-Reset": str(int(time.time() + 30)),  # 30 секунд в будущем
        "X-RateLimit-Limit": "60"
    }

    # Обновляем из заголовков
    limiter.update_from_headers(headers)

    # Проверяем, что информация о сбросе лимитов обновилась,
    # если такая информация сохраняется в классе
    assert hasattr(limiter, "last_request_times")


def test_update_from_headers_with_path():
    """Тестирование обновления лимитов из заголовков с указанием пути."""
    with patch.object(RateLimiter, 'get_endpoint_type', return_value="trade") as mock_get_type:
        limiter = RateLimiter()

        # Тестовые заголовки
        headers = {
            "X-RateLimit-Remaining": "5",
            "X-RateLimit-Reset": str(int(time.time() + 60)),
            "X-RateLimit-Limit": "30"
        }

        # Обновляем из заголовков
        limiter.update_from_headers(headers, path="/exchange/v1/buy")

        # Проверяем, что правильно определился тип эндпоинта
        mock_get_type.assert_called_once_with("/exchange/v1/buy")


@pytest.mark.asyncio
async def test_rate_limit_handling():
    """Интеграционный тест обработки лимитов."""
    limiter = RateLimiter()

    # Устанавливаем низкий лимит
    limiter.custom_limits["market"] = 4  # 4 RPS = 0.25 секунд между запросами

    start_time = time.time()

    # Выполняем несколько быстрых запросов
    for _ in range(5):
        await limiter.wait_for_rate_limit("market")

    duration = time.time() - start_time

    # Должно быть задержка примерно 4 * 0.25 = 1 секунда
    # Добавляем допуски для учёта накладных расходов и неточностей замеров
    assert 0.8 < duration < 1.5
